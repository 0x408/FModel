// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using FModel.Shop;
//
//    var shopParser = ShopParser.FromJson(jsonString);

namespace FModel.Shop
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class ShopParser
    {
        [JsonProperty("refreshIntervalHrs")]
        public long RefreshIntervalHrs { get; set; }

        [JsonProperty("dailyPurchaseHrs")]
        public long DailyPurchaseHrs { get; set; }

        [JsonProperty("expiration")]
        public DateTimeOffset Expiration { get; set; }

        [JsonProperty("storefronts")]
        public Storefront[] Storefronts { get; set; }
    }

    public partial class Storefront
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("catalogEntries")]
        public CatalogEntry[] CatalogEntries { get; set; }
    }

    public partial class CatalogEntry
    {
        [JsonProperty("offerId")]
        public string OfferId { get; set; }

        [JsonProperty("devName")]
        public string DevName { get; set; }

        [JsonProperty("offerType")]
        public OfferType OfferType { get; set; }

        [JsonProperty("prices")]
        public Price[] Prices { get; set; }

        [JsonProperty("categories")]
        public string[] Categories { get; set; }

        [JsonProperty("dailyLimit")]
        public long DailyLimit { get; set; }

        [JsonProperty("weeklyLimit")]
        public long WeeklyLimit { get; set; }

        [JsonProperty("monthlyLimit")]
        public long MonthlyLimit { get; set; }

        [JsonProperty("appStoreId")]
        public string[] AppStoreId { get; set; }

        [JsonProperty("requirements")]
        public Requirement[] Requirements { get; set; }

        [JsonProperty("metaInfo", NullValueHandling = NullValueHandling.Ignore)]
        public MetaInfo[] MetaInfo { get; set; }

        [JsonProperty("catalogGroup", NullValueHandling = NullValueHandling.Ignore)]
        public CatalogGroup? CatalogGroup { get; set; }

        [JsonProperty("catalogGroupPriority")]
        public long CatalogGroupPriority { get; set; }

        [JsonProperty("sortPriority")]
        public long SortPriority { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }

        [JsonProperty("shortDescription", NullValueHandling = NullValueHandling.Ignore)]
        public string ShortDescription { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("displayAssetPath", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplayAssetPath { get; set; }

        [JsonProperty("itemGrants")]
        public ItemGrant[] ItemGrants { get; set; }

        [JsonProperty("metaAssetInfo", NullValueHandling = NullValueHandling.Ignore)]
        public MetaAssetInfo MetaAssetInfo { get; set; }

        [JsonProperty("fulfillmentIds", NullValueHandling = NullValueHandling.Ignore)]
        public object[] FulfillmentIds { get; set; }

        [JsonProperty("matchFilter", NullValueHandling = NullValueHandling.Ignore)]
        public string MatchFilter { get; set; }

        [JsonProperty("filterWeight", NullValueHandling = NullValueHandling.Ignore)]
        public long? FilterWeight { get; set; }

        [JsonProperty("giftInfo", NullValueHandling = NullValueHandling.Ignore)]
        public GiftInfo GiftInfo { get; set; }

        [JsonProperty("refundable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Refundable { get; set; }
    }

    public partial class GiftInfo
    {
        [JsonProperty("bIsEnabled")]
        public bool BIsEnabled { get; set; }

        [JsonProperty("forcedGiftBoxTemplateId")]
        public string ForcedGiftBoxTemplateId { get; set; }

        [JsonProperty("purchaseRequirements")]
        public object[] PurchaseRequirements { get; set; }

        [JsonProperty("giftRecordIds")]
        public object[] GiftRecordIds { get; set; }
    }

    public partial class ItemGrant
    {
        [JsonProperty("templateId")]
        public string TemplateId { get; set; }

        [JsonProperty("quantity")]
        public long Quantity { get; set; }

        [JsonProperty("attributes", NullValueHandling = NullValueHandling.Ignore)]
        public Attributes Attributes { get; set; }
    }

    public partial class Attributes
    {
        [JsonProperty("Alteration")]
        public Alteration Alteration { get; set; }
    }

    public partial class Alteration
    {
        [JsonProperty("LootTierGroup")]
        public string LootTierGroup { get; set; }

        [JsonProperty("Tier")]
        public long Tier { get; set; }
    }

    public partial class MetaAssetInfo
    {
        [JsonProperty("structName")]
        public StructName StructName { get; set; }

        [JsonProperty("payload")]
        public Payload Payload { get; set; }
    }

    public partial class Payload
    {
        [JsonProperty("chaseItems")]
        public string[] ChaseItems { get; set; }

        [JsonProperty("packDefinition")]
        public string PackDefinition { get; set; }
    }

    public partial class MetaInfo
    {
        [JsonProperty("key")]
        public string Key { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public partial class Price
    {
        [JsonProperty("currencyType")]
        public CurrencyType CurrencyType { get; set; }

        [JsonProperty("currencySubType")]
        public CurrencySubType CurrencySubType { get; set; }

        [JsonProperty("regularPrice")]
        public long RegularPrice { get; set; }

        [JsonProperty("finalPrice")]
        public long FinalPrice { get; set; }

        [JsonProperty("saleExpiration")]
        public DateTimeOffset SaleExpiration { get; set; }

        [JsonProperty("basePrice")]
        public long BasePrice { get; set; }

        [JsonProperty("saleType", NullValueHandling = NullValueHandling.Ignore)]
        public string SaleType { get; set; }
    }

    public partial class Requirement
    {
        [JsonProperty("requirementType")]
        public RequirementType RequirementType { get; set; }

        [JsonProperty("requiredId")]
        public string RequiredId { get; set; }

        [JsonProperty("minQuantity")]
        public long MinQuantity { get; set; }
    }

    public enum CatalogGroup { Empty, Shared, Upgrade };

    public enum StructName { FortCatalogMeta };

    public enum OfferType { StaticPrice };

    public enum CurrencySubType { AccountResourceEventcurrencyScaling, AccountResourceEventcurrencySpring, AccountResourceVoucherBasicpack, AccountResourceVoucherCardpackBronze, AccountResourceVoucherCardpackJackpot, AccountResourceVoucherCustomFirecrackerR, Empty };

    public enum CurrencyType { GameItem, MtxCurrency, RealMoney };

    public enum RequirementType { DenyOnFulfillment, DenyOnItemOwnership, RequireFulfillment, RequireItemOwnership };

    public partial class ShopParser
    {
        public static ShopParser FromJson(string json) => JsonConvert.DeserializeObject<ShopParser>(json, FModel.Shop.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this ShopParser self) => JsonConvert.SerializeObject(self, FModel.Shop.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CatalogGroupConverter.Singleton,
                StructNameConverter.Singleton,
                OfferTypeConverter.Singleton,
                CurrencySubTypeConverter.Singleton,
                CurrencyTypeConverter.Singleton,
                RequirementTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CatalogGroupConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CatalogGroup) || t == typeof(CatalogGroup?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return CatalogGroup.Empty;
                case "Shared":
                    return CatalogGroup.Shared;
                case "Upgrade":
                    return CatalogGroup.Upgrade;
            }
            throw new Exception("Cannot unmarshal type CatalogGroup");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CatalogGroup)untypedValue;
            switch (value)
            {
                case CatalogGroup.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case CatalogGroup.Shared:
                    serializer.Serialize(writer, "Shared");
                    return;
                case CatalogGroup.Upgrade:
                    serializer.Serialize(writer, "Upgrade");
                    return;
            }
            throw new Exception("Cannot marshal type CatalogGroup");
        }

        public static readonly CatalogGroupConverter Singleton = new CatalogGroupConverter();
    }

    internal class StructNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StructName) || t == typeof(StructName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "FortCatalogMeta")
            {
                return StructName.FortCatalogMeta;
            }
            throw new Exception("Cannot unmarshal type StructName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StructName)untypedValue;
            if (value == StructName.FortCatalogMeta)
            {
                serializer.Serialize(writer, "FortCatalogMeta");
                return;
            }
            throw new Exception("Cannot marshal type StructName");
        }

        public static readonly StructNameConverter Singleton = new StructNameConverter();
    }

    internal class OfferTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OfferType) || t == typeof(OfferType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "StaticPrice")
            {
                return OfferType.StaticPrice;
            }
            throw new Exception("Cannot unmarshal type OfferType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OfferType)untypedValue;
            if (value == OfferType.StaticPrice)
            {
                serializer.Serialize(writer, "StaticPrice");
                return;
            }
            throw new Exception("Cannot marshal type OfferType");
        }

        public static readonly OfferTypeConverter Singleton = new OfferTypeConverter();
    }

    internal class CurrencySubTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CurrencySubType) || t == typeof(CurrencySubType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return CurrencySubType.Empty;
                case "AccountResource:eventcurrency_scaling":
                    return CurrencySubType.AccountResourceEventcurrencyScaling;
                case "AccountResource:eventcurrency_spring":
                    return CurrencySubType.AccountResourceEventcurrencySpring;
                case "AccountResource:voucher_basicpack":
                    return CurrencySubType.AccountResourceVoucherBasicpack;
                case "AccountResource:voucher_cardpack_bronze":
                    return CurrencySubType.AccountResourceVoucherCardpackBronze;
                case "AccountResource:voucher_cardpack_jackpot":
                    return CurrencySubType.AccountResourceVoucherCardpackJackpot;
                case "AccountResource:voucher_custom_firecracker_r":
                    return CurrencySubType.AccountResourceVoucherCustomFirecrackerR;
            }
            throw new Exception("Cannot unmarshal type CurrencySubType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CurrencySubType)untypedValue;
            switch (value)
            {
                case CurrencySubType.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case CurrencySubType.AccountResourceEventcurrencyScaling:
                    serializer.Serialize(writer, "AccountResource:eventcurrency_scaling");
                    return;
                case CurrencySubType.AccountResourceEventcurrencySpring:
                    serializer.Serialize(writer, "AccountResource:eventcurrency_spring");
                    return;
                case CurrencySubType.AccountResourceVoucherBasicpack:
                    serializer.Serialize(writer, "AccountResource:voucher_basicpack");
                    return;
                case CurrencySubType.AccountResourceVoucherCardpackBronze:
                    serializer.Serialize(writer, "AccountResource:voucher_cardpack_bronze");
                    return;
                case CurrencySubType.AccountResourceVoucherCardpackJackpot:
                    serializer.Serialize(writer, "AccountResource:voucher_cardpack_jackpot");
                    return;
                case CurrencySubType.AccountResourceVoucherCustomFirecrackerR:
                    serializer.Serialize(writer, "AccountResource:voucher_custom_firecracker_r");
                    return;
            }
            throw new Exception("Cannot marshal type CurrencySubType");
        }

        public static readonly CurrencySubTypeConverter Singleton = new CurrencySubTypeConverter();
    }

    internal class CurrencyTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CurrencyType) || t == typeof(CurrencyType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "GameItem":
                    return CurrencyType.GameItem;
                case "MtxCurrency":
                    return CurrencyType.MtxCurrency;
                case "RealMoney":
                    return CurrencyType.RealMoney;
            }
            throw new Exception("Cannot unmarshal type CurrencyType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CurrencyType)untypedValue;
            switch (value)
            {
                case CurrencyType.GameItem:
                    serializer.Serialize(writer, "GameItem");
                    return;
                case CurrencyType.MtxCurrency:
                    serializer.Serialize(writer, "MtxCurrency");
                    return;
                case CurrencyType.RealMoney:
                    serializer.Serialize(writer, "RealMoney");
                    return;
            }
            throw new Exception("Cannot marshal type CurrencyType");
        }

        public static readonly CurrencyTypeConverter Singleton = new CurrencyTypeConverter();
    }

    internal class RequirementTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RequirementType) || t == typeof(RequirementType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "DenyOnFulfillment":
                    return RequirementType.DenyOnFulfillment;
                case "DenyOnItemOwnership":
                    return RequirementType.DenyOnItemOwnership;
                case "RequireFulfillment":
                    return RequirementType.RequireFulfillment;
                case "RequireItemOwnership":
                    return RequirementType.RequireItemOwnership;
            }
            throw new Exception("Cannot unmarshal type RequirementType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RequirementType)untypedValue;
            switch (value)
            {
                case RequirementType.DenyOnFulfillment:
                    serializer.Serialize(writer, "DenyOnFulfillment");
                    return;
                case RequirementType.DenyOnItemOwnership:
                    serializer.Serialize(writer, "DenyOnItemOwnership");
                    return;
                case RequirementType.RequireFulfillment:
                    serializer.Serialize(writer, "RequireFulfillment");
                    return;
                case RequirementType.RequireItemOwnership:
                    serializer.Serialize(writer, "RequireItemOwnership");
                    return;
            }
            throw new Exception("Cannot marshal type RequirementType");
        }

        public static readonly RequirementTypeConverter Singleton = new RequirementTypeConverter();
    }
}
